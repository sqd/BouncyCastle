syntax = "proto3";


// TODO: This is a first draft, and will not be the production protocol
// Please recompile the proto after making changes. The .proto file and the pb2.py should be in sync
// You can find the compiler here: https://github.com/protocolbuffers/protobuf/releases
// On linux, it's available through apt-get. On windows you could also use choco
//
// Compile with:
//   cd to this folder
//   protoc bfcp.proto --python_out=.

package bfcp;

// See below for descriptions of each of the message types.
message BouncyMessage {
   oneof message {
       DiscoveryRequest discovery_request = 1;
       NodeTable node_table = 2;
       ConnectionRequest connection_request = 3;
       ConnectionResponse connection_response = 4;
       ChannelRequest channel_request = 5;
       ChannelResponse channel_response = 6;
       ToOriginalSender to_original_sender = 9;
       ToTargetServer to_target_server = 10;
       CloseConnectionRequest close_connection_request = 11;
   }
}

// Forming trust with a node (establishing their identity):
// A sends RsaChallenge
// B responds with RsaChallengeResponse
// if the response is valid, trust is established.

// RsaChallenge sends a message encrypted using a public key, and expects an RsaChallengeResponse
// which contains the decrypted message.
message RsaChallenge {
   bytes encrypted = 1;
}

// RsaChallengeResponse contains the decrypted message from the RsaChallenge
message RsaChallengeResponse {
   bytes decrypted = 1;
}

// RsaPubKey represents a public RSA key
message RsaPubKey {
    // All of these integers are big endian
    bytes modulus = 1;
    bytes pub_exponent = 2;
}

// In order for nodes to learn about other nodes within the network, the nodes perform discovery
// operations. This is done, by a node going to one of its trusted nodes, and askimg them for their
// list of trusted nodes.

// Requests from a node to provide a NodeTable
message DiscoveryRequest { }

// Specifies a single node in the Bouncy Network
message Node {
   // Public key of the node
   bytes public_key = 1;

   // Last known address of the node. Keep mind, that some nodes can have variable addresses. In
   // such case, this might not be valid anymore.
   string last_known_address = 2;

   // Last known port of the node. Keep mind, that some nodes can have variable ports. In such
   // case, this might not be valid anymore.
   int32 last_port = 3;
}

// NodeTableEntry specifies a single entry in the trust table of a pa.
message NodeTableEntry {
   Node node = 1;

   // How trusted is node, with 1.0 meaning absolutely trusted, and 0 meaning no trust at all.
   float trust_score = 2;
}

// Node table holds nodes in the Bouncy Network known to a particular node. This is used mostly for
// discovery of nodes in the network.
message NodeTable {
   repeated NodeTableEntry entries = 1;
}

// Routing
//
// Whenever, a node wants to connect to a target server, a ConnectionRequest is made and send to the
// next node (the next node is influenced by the EndNodeRequirements). An established connection
// allows for sending data between the original sender and the target server.

message ConnectionRoutingParams {
   // A Unique ID for the connection being made. This should be generated by the Original Sender.
   // Expected to be in the UUID format.
   string UUID = 1;

   // A number indicating how close we are to calling the current node the End Node. When remaining
   // hops reaches 0 or less, the given node becomes an end node.
   int32 remaining_hops = 2;
}

message ConnectionRequest {
   ConnectionRoutingParams connection_params = 1;

   // The requirements on the End Node. This could specify that an end node needs to be within a
   // particular country, ip subnet, etc.
   EndNodeRequirement end_node_requirement = 2;

   string target_server_address = 3;
   int32 target_server_port = 4;

   // Public key generated by the original sender to sign the messages on the created connection.
   // This key should be created only for this connection, and discarded afterwards.
   bytes sender_connection_key = 5;
}

// EndNodeRequirement specifies the requirements that the Original Sender has on the End Node. For
// example they could specifiy that the end node is located in a specific country, or that it
// belongs to a particular IP subnet.
//
// EndNodeRequirements can be arbitarly connected using Or and And operators (see definitions for
// OrRequirement, AndRequirement).
message EndNodeRequirement {
   oneof requirement {
       int32 ip_subnet = 1;

       // As specified in ISO 3166-1 (numeric) - https://www.iso.org/obp/ui/#search
       int32 country = 2;

       OrRequirement or = 3;
       AndRequirement and = 4;
   }
}

// OrRequirement joins multiple EndNodeRequirements, and expects that at least one of the specified
// requirements is satisfied.
message OrRequirement {
   repeated EndNodeRequirement requirements = 1;
}

// AndRequirement joins multiple EndNodeRequirements, and expects that all of the specified
//requirements are satisfied.
message AndRequirement {
   repeated EndNodeRequirement requirements = 1;
}

// ConnectionResponse is sent whenever a new End Node is established. The ConnectionResponse will
// do a backwards traverse of the channel that the ConnectionRequest took - all the way until the
// Original Sender.
//
// Each Network Node only remembers where they got their ConnectinoRequest from, and forwards the
// ConnectionResponse to that node.
message ConnectionResponse {
   // A Unique ID for the connection being made. This should be generated by the Original Sender.
   // Expected to be in the UUID format.
   string UUID = 1;

   NodeTableEntry selected_end_node = 2;
}

// A ChannelRequest is sent to initiate a channel between start node (SN) and end node (EN). A
// channel is formed by forming a random path from the Original Sender to the End Node. The
// nodes on the way of the channel remember their routing decision for this particular channel
// so that the messages can be resent through the same path.
message ChannelRequest {
   Node end_node = 1;
   ConnectionRoutingParams routing_params = 2;
   string channel_UUID = 3;
   bytes original_sender_signature = 4;
}

// A ChannelResponse is a response to a ChannelRequest from end node (EN) to start node (SN)
// so that SN can know a channel was established.
message ChannelResponse {
   ChannelID channel_id = 1;
}

// A ChannelID is used to identify a specific channel within a specific connection.
message ChannelID {
   string connection_UUID = 1;
   string channel_UUID = 2;
}

// ToTargetServer sends a message from Start Node (SN) to Target Server (TS). This message follows
// the links established previously by the ChannelRequest.
message ToTargetServer {
   bytes payload = 1;
   ChannelID channel_id = 2;
   bytes original_sender_signature = 3;
   int64 index = 4;
}

// ToOriginalSender sends a message from Target Server (TS) to Start Node (SN). This message follows
// the links established previously by the ChannelRequest.
message ToOriginalSender {
   bytes payload = 1;
   ChannelID channel_id = 2;
   bytes end_node_signature = 3;
   int64 index = 4;
}

// A CloseConnectionRequest is sent through the channel to notify that start node (SN) want to
// close the TCP connection with the Target Server.
message CloseConnectionRequest {
   ChannelID closed_channel = 1;
   bytes original_sender_signature = 2;
}

// First message sent by both the TCP client and the TCP server when a connection between two BFCP
// nodes is established.
message PeerHello {
    // The public key of the peer. This will be used to perform an RSA challenge
    RsaPubKey pub_key = 1;

    // The port on which the peer is serving. This is useful for discovery - when a Peer connects as
    // a TCP client, they can specify what port they are listenning on as a server. Set to <= 0 to
    // indicate that the peer does not listen for connection (e.g., peers behind NAT, etc.)
    int32 serving_port = 2;
}
