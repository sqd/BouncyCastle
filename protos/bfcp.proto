syntax = "proto3";


// TODO: This is a first draft, and will not be the production protocol
// Please recompile the proto after making changes. The .proto file and the pb2.py should be in sync
// You can find the compiler here: https://github.com/protocolbuffers/protobuf/releases
// On linux, it's available through apt-get. On windows you could also use choco
//
// Compile with:
//   cd to this folder
//   protoc bfcp.proto --python_out=.

package bfcp;

// See below for descriptions of each of the message types.
message BouncyMessage {
    oneof message {
         DiscoveryRequest discovery_request = 1;
         NodeTable node_table = 2;
         ConnectionRequest connection_request = 3;
         ConnectionResponse connection_response = 4;
         ChannelRequest channel_request = 5;
         ChannelResponse channel_response = 6;
         ToOriginalSender to_original_sender = 7;
         ToTargetServer to_target_server = 8;
    }

    // Random number of bytes added to the message. Used to hinder meta information eavesdroping.
    bytes ballast = 9;
}

// Forming trust with a node (establishing their identity):
// A sends RsaChallenge
// B responds with RsaChallengeResponse
// if the response is valid, trust is established.

// RsaChallenge sends a message encrypted using a public key, and expects an RsaChallengeResponse
// which contains the decrypted message.
message RsaChallenge {
    bytes encrypted = 1;
}

// RsaChallengeResponse contains the decrypted message from the RsaChallenge
message RsaChallengeResponse {
    bytes decrypted = 1;
}

// RsaPubKey represents a public RSA key
message RsaPubKey {
    // All of these integers are big endian
    bytes modulus = 1;
    bytes pub_exponent = 2;
}

// In order for nodes to learn about other nodes within the network, the nodes perform discovery
// operations. This is done, by a node going to one of its trusted nodes, and askimg them for their
// list of trusted nodes.

// Requests from a node to provide a NodeTable
message DiscoveryRequest { }

// Specifies a single node in the Bouncy Network
message Node {
    // Public key of the node
    RsaPubKey public_key = 1;

    // Last known address of the node. Keep mind, that some nodes can have variable addresses. In
    // such case, this might not be valid anymore.
    string last_known_address = 2;

    // Last known port of the node. Keep mind, that some nodes can have variable ports. In such
    // case, this might not be valid anymore.
    int32 last_port = 3;
}

// NodeTableEntry specifies a single entry in the trust table of a pa.
message NodeTableEntry {
    Node node = 1;

    // How trusted is node, with 1.0 meaning absolutely trusted, and 0 meaning no trust at all.
    float trust_score = 2;
}

// Node table holds nodes in the Bouncy Network known to a particular node. This is used mostly for
// discovery of nodes in the network.
message NodeTable {
    repeated NodeTableEntry entries = 1;
}

// Routing
//
// Whenever, a node wants to connect to a target server, a ConnectionRequest is made and send to the
// next node (the next node is influenced by the EndNodeRequirements). An established connection
// allows for sending data between the original sender and the target server.

message ConnectionRoutingParams {
    // A Unique ID for the connection being made. This should be generated by the Original Sender.
    // Expected to be in the UUID format.
    string uuid = 1;

    // A number indicating how close we are to calling the current node the End Node. When remaining
    // hops reaches 0 or less, the given node becomes an end node.
    int32 remaining_hops = 2;
}

message ConnectionRequest {
    ConnectionRoutingParams connection_params = 1;

    // The requirements on the End Node. This could specify that an end node needs to be within a
    // particular country, ip subnet, etc.
    EndNodeRequirement end_node_requirement = 2;

    string target_server_address = 3;
    int32 target_server_port = 4;

    // Public RSA key generated by the original sender to sign the messages on the created
    // connection. This key should be created only for this connection, and discarded afterwards.
    RsaPubKey sender_connection_key = 5;

    // Bytes to be signed by the End Node. This way, we can verify the identity of the EndNode.
    bytes signature_challenge = 6;
}

// EndNodeRequirement specifies the requirements that the Original Sender has on the End Node. For
// example they could specifiy that the end node is located in a specific country, or that it
// belongs to a particular IP subnet.
//
// EndNodeRequirements can be arbitarly connected using Or and And operators (see definitions for
// OrRequirement, AndRequirement).
message EndNodeRequirement {
    oneof requirement {
         int32 ip_subnet = 1;

         // As specified in ISO 3166-1 (numeric) - https://www.iso.org/obp/ui/#search
         int32 country = 2;

         OrRequirement or = 3;
         AndRequirement and = 4;
    }
}

// OrRequirement joins multiple EndNodeRequirements, and expects that at least one of the specified
// requirements is satisfied.
message OrRequirement {
    repeated EndNodeRequirement requirements = 1;
}

// AndRequirement joins multiple EndNodeRequirements, and expects that all of the specified
//requirements are satisfied.
message AndRequirement {
    repeated EndNodeRequirement requirements = 1;
}

// ConnectionResponse is sent whenever a new End Node is established. The ConnectionResponse will
// do a backwards traverse of the channel that the ConnectionRequest took - all the way until the
// Original Sender.
//
// Each Network Node only remembers where they got their ConnectinoRequest from, and forwards the
// ConnectionResponse to that node.
message ConnectionResponse {
    // A Unique ID for the connection being made. This should be generated by the Original Sender.
    // Expected to be in the UUID format.
    string uuid = 1;

    Node selected_end_node = 2;

    // ConnectionRequest.signature_challenge bytes signed with the public key of the end node.
    bytes signature_challenge_response = 3;

    // Session key generated by the end node and encrypted using the connection key created by the
    // original sender. This session key will be used to encrypt the payload in ToTargetServer and
    // ToOriginalSender messages. It also verifies the identity of the original sender to the end
    // node - only the original sender will be able to read the session key.
    AESKey session_key = 4;
}

// A ChannelRequest is sent to initiate a channel between start node (SN) and end node (EN). A
// channel is formed by forming a random path from the Original Sender to the End Node. The
// nodes on the way of the channel remember their routing decision for this particular channel
// so that the messages can be resent through the same path.
message ChannelRequest {
    Node end_node = 1;
    ConnectionRoutingParams routing_params = 2;
    string channel_uuid = 3;
}

// A ChannelResponse is a response to a ChannelRequest from end node (EN) to start node (SN)
// so that SN can know a channel was established.
message ChannelResponse {
    ChannelID channel_id = 1;
}

// A ChannelID is used to identify a specific channel within a specific connection.
message ChannelID {
    string connection_uuid = 1;
    string channel_uuid = 2;
}

// This will be the payload of ToTargetServer and ToOriginalSender messages.
message BouncyTcpMessage {
    // If this is empty, the connection is closed
    bytes payload = 1;

    // Index of the message, with 0 being the first message. Note that the "closed connection"
    // message (with empty payload) should have index one higher than the last message with actual
    // payload.
    int64 index = 2;
}

// ToTargetServer sends a message from Start Node (SN) to Target Server (TS). This message follows
// the links established previously by the ChannelRequest.
message ToTargetServer {
    // Payload is an AES encrypted BouncyTcpMessage
    bytes payload = 1;
    ChannelID channel_id = 2;
}

// ToOriginalSender sends a message from Target Server (TS) to Start Node (SN). This message follows
// the links established previously by the ChannelRequest.
message ToOriginalSender {
    // Payload is an AES encrypted BouncyTcpMessage
    bytes payload = 1;
    ChannelID channel_id = 2;
}

// First message sent by both the TCP client and the TCP server when a connection between two BFCP
// nodes is established.
message PeerHello {
    // The public key of the peer. This will be used to perform an RSA challenge
    RsaPubKey pub_key = 1;

    // The port on which the peer is serving. This is useful for discovery - when a Peer connects as
    // a TCP client, they can specify what port they are listenning on as a server. Set to <= 0 to
    // indicate that the peer does not listen for connection (e.g., peers behind NAT, etc.)
    int32 serving_port = 2;
}

// Bytes of an AES key
message AESKey {
    // The public key of the peer. This will be used to perform an RSA challenge. Should be
    // encrypted with the public key of the receiver
    bytes key = 1;
}
